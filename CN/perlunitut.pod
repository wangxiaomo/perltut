
        *****************************************************
        *           GENERATED FILE, DO NOT EDIT             * 
        * THIS IS NO SOURCE FILE, BUT RESULT OF COMPILATION *
        *****************************************************

This file was generated by po4a(7). Do not store it (in VCS, for example),
but store the PO file used as source file by po4a-translate. 

In fact, consider this as a binary, and the PO file as a regular .c file:
If the PO get lost, keeping this translation up-to-date will be harder.

=encoding UTF-8

=head1 NAME

perlunitut - Perl Unicode 指南

=head1 DESCRIPTION

好的编程语言应该对多种字符编码有所支持。

关于字符编码有很多内容，我们可能需要用一整天来学习，但是基本的知识却可以在几分钟内掌握。

本篇文档包含关于编码最基本的知识。我们假设你知道不同编码存储结构不同等知识。

This tutorial speaks in rather absolute terms, and provides only a limited
view of the wealth of character string related features that Perl has to
offer. For most projects, this information will probably suffice.

=head2 一些定义

It's important to set a few things straight first. This is the most
important part of this tutorial. This view may conflict with other
information that you may have found on the web, but that's mostly because
many sources are wrong.

You may have to re-read this entire section a few times...

=head3 Unicode

B<Unicode> 是一种字符编码体系。

There are many, many code points, but computers work with bytes, and a byte
has room for only 256 values.  Unicode has many more characters, so you need
a method to make these accessible.

Unicode 体系中有很多编码形式，UTF-8 是最常用的一种。

=head3 UTF-8

B<UTF-8> 是 Unicode 编码体系中最常用的一种。许多人认为 Unicode 和 UTF-8 是相同的东西，但是它们却不是。

UTF-8 treats the first 128 codepoints, 0..127, the same as ASCII. They take
only one byte per character. All other characters are encoded as two or more
(up to six) bytes using a complex scheme. Fortunately, Perl handles this for
us, so we don't have to worry about this.

=head3 文本字符串

B<文本字符串>是由字符构成的。字节和编码跟它都没有什么太大关系，字符就是字符而已。

在一个文本字符串中，你可以这样做：

    $text =~ s/foo/bar/;
    if ($string =~ /^\d+$/) { ... }
    $text = ucfirst $text;
    my $character_count = length $text;

C<ord>、C<chr> 可以将字符与 ASCII 编码之间进行转化。

=head3 二进制字符串

B<二进制字符串>是由字节构成的。这里你将看不到任何字符，只有字节而已。所有对其的操作都是在二进制基础上完成的。

对一个二进制字符串，你可以这么做：

    my (@length_content) = unpack "(V/a)*", $binary;
    $binary =~ s/\x00\x0F/\xFF\xF0/;  # for the brave :)
    print {$fh} $binary;
    my $byte_count = length $binary;

=head3 编码

B<编码>是从文本字符串转化为二进制字符串。编码的时候你需要首先指定编码格式，如 C<iso-8859-1> 或
C<UTF-8>。有一些编码并不支持所有的字符。

=head3 解码

B<解码>是从二进制字符串转化为文本字符串。解码的时候你需要首先知道编码格式。否则无法正确解码。

=head3 内置格式

Perl 有B<内置格式>。

你不需要知道内置格式是什么，因为 Perl 会自动为你编码、解码。

=head2 工具

在你的代码开始处加入如下代码：

    use Encode qw(encode decode);

或者偷懒的话，使用：

    use Encode;

=head2 I/O 操作（真正的5分钟指南）

输入输出流程如下：

    1. Receive and decode
    2. Process
    3. Encode and output

如果你的输入为二进制字符串，而且想要得到的就是二进制字符串，那么你什么都不需要做。但是在我们的指南中，我们需要对其解码得到文本字符串。

如果你不知道编码格式是什么的话，解码过程不一定会顺利完成。如果随便选一种的话，最好是标准的格式 UTF-8。

    my $foo   = decode('UTF-8', get 'http://example.com/');
    my $bar   = decode('ISO-8859-1', readline STDIN);
    my $xyzzy = decode('Windows-1251', $cgi->param('foo'));

用 C<substr>、C<length> 等来处理数据。

最后将处理好的数据编码成相应的编码格式。

编码代码和解码代码一样简单，如下：

    $body = encode('UTF-8', $body);

如果你想要知道该字符串占多少字节，现在才是查看的时候。因为 C<$body> 现在是二进制字符串，你可以通过 C<length> 方法得到它的长度。

    my $byte_count = length $body;

And if the protocol you're using supports a way of letting the recipient
know which character encoding you used, please help the receiving end by
using that feature! For example, E-mail and HTTP support MIME headers, so
you can use the C<Content-Type> header. They can also have C<Content-Length>
to indicate the number of I<bytes>, which is always a good idea to supply if
the number is known.

    "Content-Type: text/plain; charset=UTF-8",
    "Content-Length: $byte_count"

=head1 总结

获得输入后解码，发送输出前编码。

=head1 FAQ

读完本篇文档，你应该再去读 L<perlunifaq>。

=head1 鸣谢

Thanks to Johan Vromans from Squirrel Consultancy. His UTF-8 rants during
the Amsterdam Perl Mongers meetings got me interested and determined to find
out how to use character encodings in Perl in ways that don't break easily.

Thanks to Gerard Goossen from TTY. His presentation "UTF-8 in the wild"
(Dutch Perl Workshop 2006) inspired me to publish my thoughts and write this
tutorial.

Thanks to the people who asked about this kind of stuff in several Perl IRC
channels, and have constantly reminded me that a simpler explanation was
needed.

Thanks to the people who reviewed this document for me, before it went
public.  They are: Benjamin Smith, Jan-Pieter Cornet, Johan Vromans, Lukas
Mai, Nathan Gray.

=head1 AUTHOR

Juerd Waalboer <#####@juerd.nl>

译者：xiaomo(wxm4ever@gmail.com)

=head1 另见

L<perlunifaq>, L<perlunicode>, L<perluniintro>, L<Encode>

